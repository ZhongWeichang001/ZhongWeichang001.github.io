[{"categories":["ubuntu"],"content":"概述 由于在 Windows 环境下做开发，在配置环境方面经常会遇到各种问题，因此，选择使用 Ubuntu 来作为开发环境，版本为 Ubuntu 20.04。 Ubuntu 使用 apt 作为软件包管理器，其默认的下载源在国外，为了加快软件下载速度，建议在安装好系统之后就修改为国内的镜像源，常见的国内源包括：阿里源、清华源、中科大源等，完整的官方镜像源列表可以查看 Mirrors : Ubuntu。 这里使用阿里源为例，展示如何进行修改。 备份旧的 apt 配置文件 apt 配置文件位于 /etc/apt 目录下，其中 sources.list 文件是 apt 用来记录镜像源配置信息的，建议在修改之前对其进行备份： sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak 查看 Ubuntu 版本代号 使用 lsb_release 命令来查看 Ubuntu 版本代号： $ lsb_release --codename Codename: focal 每个版本的代号都是不一样的，例如： Ubuntu 22.10：kinetic Ubuntu 22.04：jammy Ubuntu 21.10：impish Ubuntu 20.04：focal Ubuntu 18.04：bionic Note 我在这边踩过一次坑，我用的是 20.04 版本，版本代号应该为 focal，但是修改源时使用了 18.04 的代号 bionic，导致后面在安装软件时遇到各种报错信息，通过排查才知道是自己版本代号配置错了。 编辑新的 apt 配置文件 sudo vi /etc/apt/sources.list 修改 apt 源为阿里源： deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse 如果需要使用其他的源，只需要修改镜像地址即可，常见的软件源的地址如下： 清华源：https://mirrors.tuna.tsinghua.edu.cn/ubuntu 中科大源：http://mirrors.ustc.edu.cn/ubuntu 南大源：https://mirror.nju.edu.cn/ubuntu 网易源：http://mirrors.163.com/ubuntu 更新软件列表 执行如下命令更新软件列表索引： sudo apt update -y 更新软件包 执行如下命令升级软件包： sudo apt upgrade 参考资料 Ubuntu Manpage: sources.list - List of configured APT data sources Mirrors : Ubuntu ","date":"2022-06-21","objectID":"/2022_06_21_ubuntu_modify_apt_source/:0:0","tags":["ubuntu","apt"],"title":"Ubuntu 20.04 LTS 修改 apt 源","uri":"/2022_06_21_ubuntu_modify_apt_source/"},{"categories":null,"content":"关于我 一个平平无奇的计算机专业在读研究生。 ","date":"2022-06-05","objectID":"/about/:0:0","tags":null,"title":"About","uri":"/about/"},{"categories":["algorithm"],"content":"素性测试 素数：若整数 $n ( n \u003e 1)$ 只有 $1$ 和 $n$ 两个因数，则 $n$ 为素数。 ","date":"2022-06-05","objectID":"/2022_06_05_primes/:0:0","tags":["math","algorithm"],"title":"素数","uri":"/2022_06_05_primes/"},{"categories":["algorithm"],"content":"试除法 判断一个数 $n$ 是否为素数，最直接的办法是按照定义判断，依次看 $2,3,\\cdots,n-1$ 能否整除 $n$，若能整除则 $n$ 为合数，都不能整除则 $n$ 为素数，算法时间复杂度为 $O(n)$。 // 素性测试 bool isPrime(int n) { if (n \u003c 2) { return false; } else { for(int i = 2; i \u003c n - 1; i++) { if (n % i == 0) { return false; } } return true; } } 若 $n$ 为合数，则 $\\exists s \\geq t \\in N_{+} 且 s \\geq t \u003e 1$ 使得 $n = st$， 于是有 $t \\leq \\sqrt{n}$，也就是说合数 $n$ 一定存在一个因数小于等于 $\\sqrt{n}$。 因此我们只需要对 $2,3,\\cdots,\\sqrt{n}$ 判断是否能整除 $n$ 即可。因此上述算法时间复杂度可降为 $O(\\sqrt{n})$. // 素性测试 bool isPrime(int n) { if (n \u003c 2) { return false; } else { for (int i = 2; i * i \u003c= n; i++) { if (n % i == 0) { return false; } } return true; } } 打印素数表 ","date":"2022-06-05","objectID":"/2022_06_05_primes/:1:0","tags":["math","algorithm"],"title":"素数","uri":"/2022_06_05_primes/"},{"categories":["algorithm"],"content":"Eratosthenes 筛法 算法思想是用已知素数的倍数去过滤掉那些合数，算法复杂度为 $O(n \\log{\\log n})$. #include \u003cvector\u003e using namespace std; // Eratosthenes 筛法返回小于等于 n 的素数表 vector\u003cint\u003e eratosthenes(int n) { vector\u003cint\u003e primes; if (n \u003c 2) { return primes; } vector\u003cint\u003e check(n + 1); for (int i = 2; i \u003c= n; i++) { if (!check[i]) { primes.push_back(i); for (int j = 2 * i; j \u003c= n; j += i) { check[j] = true; } } } return primes; } ","date":"2022-06-05","objectID":"/2022_06_05_primes/:2:0","tags":["math","algorithm"],"title":"素数","uri":"/2022_06_05_primes/"},{"categories":["algorithm"],"content":"Euler 筛法 Euler 筛法也称线性筛法，时间复杂度为 $O(n)$. #include \u003cvector\u003e using namespace std; // Euler 筛法 vector\u003cint\u003e euler(int n) { vector\u003cint\u003e primes; if (n \u003c 2) { return primes; } vector\u003cint\u003e check(n + 1); for (int i = 2; i \u003c= n; i++) { if (!check[i]) { primes.push_back(i); } for (int j = 0; j \u003c primes.size() \u0026\u0026 i * primes[j] \u003c= n; j++) { check[i * primes[j]] = true; if (i % primes[j] == 0) { break; } } } return primes; } 素因子分解 #include \u003cvector\u003e using namespace std; // 素因子分解: 试除法 vector\u003cpair\u003cint, int\u003e\u003e getPrimeFactorization(int n) { // factorization[i][0] 和 factorization[i][1] 表示第 i 个素因子及其指数 // 素因子从小到达排序 vector\u003cpair\u003cint, int\u003e\u003e factorization; for (int i = 2; i * i \u003c= n; ++i) { if (n % i == 0) { int index = 0; while (n % i == 0) { n /= i; ++index; } factorization.emplace_back(i, index); } } if (n != 1) { factorization.emplace_back(n, 1); } return factorization; } ","date":"2022-06-05","objectID":"/2022_06_05_primes/:3:0","tags":["math","algorithm"],"title":"素数","uri":"/2022_06_05_primes/"}]